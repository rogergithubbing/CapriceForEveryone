/*
    CaPriCe Forever - Amstrad CPC 464/664/6128 emulator
    Copyright (C) 2014-2015 by Frédéric Coste

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "..\MFM.h"


//
// MFM Coding
//
// Bit 1 = 01
// Bit 0 = 00 or 10 if previous was 0
//
// Hence 0x59 is
// Bit   0   1   0   1   1   0   0   1
// MFM  1 0 0 1 0 0 0 1 0 1 0 0 1 0 0 1
//



//===================
// PATCH begin

#define _PATCH_ENABLE
#ifdef _PATCH_ENABLE

#undef PATCH_1
#undef PATCH_2
#undef PATCH_3
#define PATCH_1
#define PATCH_2
#define PATCH_3

#endif /* _PATCH_ENABLE */
// PATCH end
//===================

/*
** Make sure we can call this stuff from C++.
*/
#ifdef __cplusplus
extern "C" {
#endif



#ifndef PATCH_2
// Table to convert one MFM pulse shift
static tUChar const MFMPulseShiftTable[] =
{
  0xFF,0xFE,0xFC,0xFC,0xF9,0xF8,0xF8,0xF8,0xF3,0xF2,0xF0,0xF0,0xF1,0xF0,0xF0,0xF0,
  0xE7,0xE6,0xE4,0xE4,0xE1,0xE0,0xE0,0xE0,0xE3,0xE2,0xE0,0xE0,0xE1,0xE0,0xE0,0xE0,
  0xCF,0xCE,0xCC,0xCC,0xC9,0xC8,0xC8,0xC8,0xC3,0xC2,0xC0,0xC0,0xC1,0xC0,0xC0,0xC0,
  0xC7,0xC6,0xC4,0xC4,0xC1,0xC0,0xC0,0xC0,0xC3,0xC2,0xC0,0xC0,0xC1,0xC0,0xC0,0xC0,
  0x9F,0x9E,0x9C,0x9C,0x99,0x98,0x98,0x98,0x93,0x92,0x90,0x90,0x91,0x90,0x90,0x90,
  0x87,0x86,0x84,0x84,0x81,0x80,0x80,0x80,0x83,0x82,0x80,0x80,0x81,0x80,0x80,0x80,
  0x8F,0x8E,0x8C,0x8C,0x89,0x88,0x88,0x88,0x83,0x82,0x80,0x80,0x81,0x80,0x80,0x80,
  0x87,0x86,0x84,0x84,0x81,0x80,0x80,0x80,0x83,0x82,0x80,0x80,0x81,0x80,0x80,0x80,
  0x3F,0x3E,0x3C,0x3C,0x39,0x38,0x38,0x38,0x33,0x32,0x30,0x30,0x31,0x30,0x30,0x30,
  0x27,0x26,0x24,0x24,0x21,0x20,0x20,0x20,0x23,0x22,0x20,0x20,0x21,0x20,0x20,0x20,
  0x0F,0x0E,0x0C,0x0C,0x09,0x08,0x08,0x08,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x07,0x06,0x04,0x04,0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x1F,0x1E,0x1C,0x1C,0x19,0x18,0x18,0x18,0x13,0x12,0x10,0x10,0x11,0x10,0x10,0x10,
  0x07,0x06,0x04,0x04,0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x0F,0x0E,0x0C,0x0C,0x09,0x08,0x08,0x08,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x07,0x06,0x04,0x04,0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
};
#else /* PATCH_2 */
static tUChar const MFMHalfPulseTableFrom0[] =
{
  0xFF,0xFE,0xFC,0xFC,0xF9,0xF8,0xF8,0xF8,0xF3,0xF2,0xF0,0xF0,0xF1,0xF0,0xF0,0xF0,
  0xE7,0xE6,0xE4,0xE4,0xE1,0xE0,0xE0,0xE0,0xE3,0xE2,0xE0,0xE0,0xE1,0xE0,0xE0,0xE0,
  0xCF,0xCE,0xCC,0xCC,0xC9,0xC8,0xC8,0xC8,0xC3,0xC2,0xC0,0xC0,0xC1,0xC0,0xC0,0xC0,
  0xC7,0xC6,0xC4,0xC4,0xC1,0xC0,0xC0,0xC0,0xC3,0xC2,0xC0,0xC0,0xC1,0xC0,0xC0,0xC0,
  0x9F,0x9E,0x9C,0x9C,0x99,0x98,0x98,0x98,0x93,0x92,0x90,0x90,0x91,0x90,0x90,0x90,
  0x87,0x86,0x84,0x84,0x81,0x80,0x80,0x80,0x83,0x82,0x80,0x80,0x81,0x80,0x80,0x80,
  0x8F,0x8E,0x8C,0x8C,0x89,0x88,0x88,0x88,0x83,0x82,0x80,0x80,0x81,0x80,0x80,0x80,
  0x87,0x86,0x84,0x84,0x81,0x80,0x80,0x80,0x83,0x82,0x80,0x80,0x81,0x80,0x80,0x80,
  0x3F,0x3E,0x3C,0x3C,0x39,0x38,0x38,0x38,0x33,0x32,0x30,0x30,0x31,0x30,0x30,0x30,
  0x27,0x26,0x24,0x24,0x21,0x20,0x20,0x20,0x23,0x22,0x20,0x20,0x21,0x20,0x20,0x20,
  0x0F,0x0E,0x0C,0x0C,0x09,0x08,0x08,0x08,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x07,0x06,0x04,0x04,0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x1F,0x1E,0x1C,0x1C,0x19,0x18,0x18,0x18,0x13,0x12,0x10,0x10,0x11,0x10,0x10,0x10,
  0x07,0x06,0x04,0x04,0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x0F,0x0E,0x0C,0x0C,0x09,0x08,0x08,0x08,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x07,0x06,0x04,0x04,0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
};
static tUChar const MFMHalfPulseTableFrom1[] =
{
  0x7F,0x7E,0x7C,0x7C,0x79,0x78,0x78,0x78,0x73,0x72,0x70,0x70,0x71,0x70,0x70,0x70,
  0x67,0x66,0x64,0x64,0x61,0x60,0x60,0x60,0x63,0x62,0x60,0x60,0x61,0x60,0x60,0x60,
  0x4F,0x4E,0x4C,0x4C,0x49,0x48,0x48,0x48,0x43,0x42,0x40,0x40,0x41,0x40,0x40,0x40,
  0x47,0x46,0x44,0x44,0x41,0x40,0x40,0x40,0x43,0x42,0x40,0x40,0x41,0x40,0x40,0x40,
  0x1F,0x1E,0x1C,0x1C,0x19,0x18,0x18,0x18,0x13,0x12,0x10,0x10,0x11,0x10,0x10,0x10,
  0x07,0x06,0x04,0x04,0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x0F,0x0E,0x0C,0x0C,0x09,0x08,0x08,0x08,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x07,0x06,0x04,0x04,0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x3F,0x3E,0x3C,0x3C,0x39,0x38,0x38,0x38,0x33,0x32,0x30,0x30,0x31,0x30,0x30,0x30,
  0x27,0x26,0x24,0x24,0x21,0x20,0x20,0x20,0x23,0x22,0x20,0x20,0x21,0x20,0x20,0x20,
  0x0F,0x0E,0x0C,0x0C,0x09,0x08,0x08,0x08,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x07,0x06,0x04,0x04,0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x1F,0x1E,0x1C,0x1C,0x19,0x18,0x18,0x18,0x13,0x12,0x10,0x10,0x11,0x10,0x10,0x10,
  0x07,0x06,0x04,0x04,0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x0F,0x0E,0x0C,0x0C,0x09,0x08,0x08,0x08,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
  0x07,0x06,0x04,0x04,0x01,0x00,0x00,0x00,0x03,0x02,0x00,0x00,0x01,0x00,0x00,0x00,
};
#endif /* PATCH_2 */


tVoid DetectMFMShift(tUChar Expected, tUChar Source, tUChar* BitShift, tUChar* PulseShift)
/***********************************************************************
 *
 *  DetectMFMShift
 *
 ***********************************************************************/
{
tUChar Loop;

  *BitShift = 0;
  *PulseShift = 0;

  for (Loop=0; Loop < 8; Loop++)
  {
    if (Expected == Source)
    {
      *BitShift = Loop;
      break;
    }
#ifndef PATCH_2
    else if (Expected == MFMPulseShiftTable[Source])
#else /* PATCH_2 */
    else if (Expected == MFMHalfPulseTableFrom0[Source])
#endif /* PATCH_2 */
    {
      *BitShift = Loop;
      *PulseShift = 1;
      break;
    }
    else
    {
      // Rotate left 1 bit
      Source = (Source << 1) | (Source >> 7);
    }
  }
}
/*----------------------------------------------------------------------------*/


tVoid MFMShift(tUChar* dataP, tULong numBytes, tUChar Shift, tUChar PulseShift)
/***********************************************************************
 *
 *  MFMShift
 *
 ***********************************************************************/
{
  if (!numBytes) return;

#ifndef PATCH_1

  // Apply Bit shift
  if (Shift)
  {
    tUChar* SourceDataP = dataP;
    tULong  Length = numBytes;

    while (Length--)
    {
      tUShort Shifted = (tUShort)*SourceDataP << Shift;

      if (SourceDataP > dataP)
      {
        *(SourceDataP-1) |= (tUChar)(Shifted >> 8);
      }
      *SourceDataP = (tUChar)Shifted;
      SourceDataP++;
    }
  }

#else /* PATCH_1 */

  // Apply Bit shift
  if (Shift)
  {
    tUChar* SourceDataP = dataP;
    tULong  Length = numBytes;

#ifndef PATCH_3
    while (Length--)
    {
      *SourceDataP = *SourceDataP << Shift;
      if (Length)
      {
        tUShort Shifted = *(SourceDataP+1) << Shift;
        *SourceDataP |= (tUChar)(Shifted >> 8);
      }
      SourceDataP++;
    }
#else /* PATCH_3 */
    tUShort Shifted = *SourceDataP;
    Shift = 8 - Shift;
    while (Length--)
    {
      Shifted = Shifted << 8;
      if (Length)
      {
        Shifted |= *(SourceDataP+1);
      }
      *(SourceDataP++) = (tUChar)(Shifted >> Shift);
    }
#endif /* PATCH_3 */
  }

#endif /* PATCH_1 */

#ifndef PATCH_2
  // Apply Pulse shift
  if (PulseShift)
  {
    while (numBytes--)
    {
      *dataP = MFMPulseShiftTable[*dataP];
      dataP++;
    }
  }
#else /* PATCH_2 */
  // Apply Pulse shift
  if (PulseShift)
  {
    tUChar LastBit = 0;
    while (numBytes--)
    {
      tUChar LastByte = *dataP;
      *(dataP++) = LastBit ? MFMHalfPulseTableFrom1[LastByte] : MFMHalfPulseTableFrom0[LastByte];
      LastBit = LastByte & 0x01;
    }
  }
#endif /* PATCH_2 */

}
/*----------------------------------------------------------------------------*/


tVoid MFMShiftWithCopy(tUChar* destP,
                       tUChar* sourceP,
                       tULong numBytes,
                       tUChar Shift,
                       tUChar PulseShift)
/***********************************************************************
 *
 *  MFMShiftWithCopy
 *
 ***********************************************************************/
{
  if (!numBytes) return;

  // Apply Bit shift
  if (Shift)
  {
    tUChar* SourceDataP = sourceP;
    tUChar* DestDataP = destP;
    tULong  Length = numBytes;

    tUShort Shifted = *(SourceDataP++);
    Shift = 8 - Shift;
    while (Length--)
    {
      Shifted = Shifted << 8;
      if (Length)
      {
        Shifted |= *(SourceDataP++);
      }
      *(DestDataP++) = (tUChar)(Shifted >> Shift);
    }
  }

  // Apply Pulse shift
  if (PulseShift)
  {
    tUChar LastBit = 0;
    while (numBytes--)
    {
      tUChar LastByte = *destP;
      *(destP++) = LastBit ? MFMHalfPulseTableFrom1[LastByte] : MFMHalfPulseTableFrom0[LastByte];
      LastBit = LastByte & 0x01;
    }
  }
}
/*----------------------------------------------------------------------------*/


tUChar GetByteFromPulses(tUChar* Bits)
/***********************************************************************
 *
 *  GetByteFromPulses
 *
 ***********************************************************************/
{
tUShort Pulses = (*Bits << 8) | *(Bits+1);
tUChar Byte = 0;
tUChar Loop;

  for (Loop=0; Loop < 8; Loop++)
  {
    // Get last 2 MFM bits
    tUShort Bit = Pulses >> 14;

    Byte = Byte << 1;
    if (Bit == 1)
    {
      Byte |= 0x01;
    }

    // Next 2 MFM bits
    Pulses = Pulses << 2;
  }

  return Byte;
}
//---------------------------------------------------------------------------


tUChar GetHalfByteFromPulses(tUChar* Bits)
/***********************************************************************
 *
 *  GetHalfByteFromPulses
 *
 ***********************************************************************/
{
tUChar Byte = 0;
tUChar Loop;
tUShort Pulses = *Bits << 8;

  for (Loop=0; Loop < 8; Loop++)
  {
    tUShort Bit = Pulses >> 14;

    Byte = Byte << 1;
    if (Bit == 1)
    {
      Byte |= 0x01;
    }

    Pulses = Pulses << 2;
  }

  return Byte;
}
//---------------------------------------------------------------------------


#ifdef __cplusplus
}  /* End of the 'extern "C"' block */
#endif
